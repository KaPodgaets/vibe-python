diff --git a/configs/.gitkeep b/configs/.gitkeep
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/configs/.gitkeep
diff --git a/configs/robots.d/.gitkeep b/configs/robots.d/.gitkeep
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/configs/robots.d/.gitkeep
diff --git a/pyproject.toml b/pyproject.toml
new file mode 100644
index 0000000..3793f0b
--- /dev/null
+++ b/pyproject.toml
@@ -0,0 +1,18 @@
+[project]
+name = "vibe-python"
+version = "0.1.0"
+description = "Python-based RPA Orchestrator"
+dependencies = [
+    "typer[all]",
+    "pydantic",
+    "python-dotenv",
+    "pyautogui",
+    "SQLAlchemy",
+    "pyodbc"
+]
+
+[project.scripts]
+vibe-python = "vibe_python.main:app"
+
+[tool.setuptools.packages.find]
+where = ["src"]
diff --git a/scripts/.gitkeep b/scripts/.gitkeep
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/scripts/.gitkeep
diff --git a/src/main.py b/src/main.py
deleted file mode 100644
index e69de29..0000000
diff --git a/src/vibe_python/__init__.py b/src/vibe_python/__init__.py
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/vibe_python/__init__.py
diff --git a/src/vibe_python/config.py b/src/vibe_python/config.py
new file mode 100644
index 0000000..6b16e87
--- /dev/null
+++ b/src/vibe_python/config.py
@@ -0,0 +1,41 @@
+import json
+from pathlib import Path
+from typing import List, Optional, Dict
+
+from .models import Robot
+
+# For Phase 1, we will use a single file as a starting point.
+# The path is relative to the project root.
+CONFIG_FILE_PATH = Path("configs/sample_robot.json")
+
+class ConfigManager:
+    """
+    A simple configuration manager for Phase 1.
+
+    It loads a single hardcoded JSON file which can contain a single robot
+    object or a list of robot objects. A more robust directory-based loader
+    will be implemented in a later phase.
+    """
+    def __init__(self):
+        self._robots: Dict[str, Robot] = {}
+        self._load_robots()
+
+    def _load_robots(self):
+        if not CONFIG_FILE_PATH.exists():
+            print(f"Warning: Configuration file not found at '{CONFIG_FILE_PATH}'. No robots will be loaded.")
+            return
+
+        with open(CONFIG_FILE_PATH, "r") as f:
+            robots_data = json.load(f)
+            
+            robots_to_load = []
+            if isinstance(robots_data, list):
+                robots_to_load = [Robot.model_validate(r) for r in robots_data]
+            elif isinstance(robots_data, dict):
+                 robots_to_load = [Robot.model_validate(robots_data)]
+
+            self._robots = {r.robot_name: r for r in robots_to_load}
+            print(f"Loaded {len(self._robots)} robot(s) from {CONFIG_FILE_PATH}.")
+
+    def get_all_robots(self) -> List[Robot]:
+        return list(self._robots.values())
+
+    def get_robot(self, robot_name: str) -> Optional[Robot]:
+        return self._robots.get(robot_name)
diff --git a/src/vibe_python/executor.py b/src/vibe_python/executor.py
new file mode 100644
index 0000000..202f5a6
--- /dev/null
+++ b/src/vibe_python/executor.py
@@ -0,0 +1,73 @@
+import pyautogui
+import time
+import threading
+from .models import Robot, Action
+
+_keep_alive_thread = None
+_keep_alive_stop_event = threading.Event()
+
+def _session_keep_alive_worker():
+    """
+    Worker function to periodically move the mouse slightly to prevent
+    RDP session lock or screen saver activation.
+    """
+    print("Session keep-alive worker started.")
+    while not _keep_alive_stop_event.wait(timeout=180): # 3-minute interval
+        try:
+            current_pos = pyautogui.position()
+            # A very small, quick, and non-disruptive move
+            pyautogui.move(1, 1, duration=0.1)
+            pyautogui.move(-1, -1, duration=0.1)
+            # Ensure the mouse returns exactly to its original position
+            pyautogui.moveTo(current_pos)
+            print("Keep-alive tick.")
+        except pyautogui.FailSafeException:
+            print("Fail-safe triggered during keep-alive. Pausing keep-alive.")
+            # If user moves mouse to a corner, wait longer before trying again
+            time.sleep(60)
+    print("Session keep-alive worker stopped.")
+
+def start_session_keep_alive():
+    """Starts the session keep-alive mechanism in a background thread."""
+    global _keep_alive_thread
+    if _keep_alive_thread is None or not _keep_alive_thread.is_alive():
+        _keep_alive_stop_event.clear()
+        _keep_alive_thread = threading.Thread(target=_session_keep_alive_worker, daemon=True)
+        _keep_alive_thread.start()
+
+def stop_session_keep_alive():
+    """Stops the session keep-alive mechanism."""
+    global _keep_alive_thread
+    if _keep_alive_thread and _keep_alive_thread.is_alive():
+        _keep_alive_stop_event.set()
+        _keep_alive_thread.join(timeout=5)
+        _keep_alive_thread = None
+
+def execute_action(action: Action):
+    """Translates a single Action model into a pyautogui call."""
+    action_map = {
+        "move_to": lambda p: pyautogui.moveTo(p.get('x'), p.get('y'), duration=p.get('duration', 0.2)),
+        "click": lambda p: pyautogui.click(**p),
+        "double_click": lambda p: pyautogui.doubleClick(**p),
+        "write": lambda p: pyautogui.write(p.get('text', ''), interval=p.get('interval', 0.05)),
+        "press": lambda p: pyautogui.press(p.get('keys')),
+        "hotkey": lambda p: pyautogui.hotkey(*p.get('keys', [])),
+        "screenshot": lambda p: pyautogui.screenshot(p.get('filename')),
+        "wait": lambda p: time.sleep(p.get('seconds', 1)),
+    }
+    
+    if action.type in action_map:
+        action_map[action.type](action.params)
+    else:
+        raise ValueError(f"Unknown action type: {action.type}")
+
+def execute_robot(robot: Robot):
+    """Executes the sequence of actions for a given robot (Phase 1 basic implementation)."""
+    print(f"--- Starting execution for robot: {robot.robot_name} ---")
+    for i, action in enumerate(robot.actions):
+        print(f"Step {i+1}: Executing action '{action.type}' - {action.description or ''}")
+        try:
+            execute_action(action)
+        except Exception as e:
+            print(f"!!! ERROR on step {i+1} ({action.type}): {e}")
+            print(f"--- Halting execution for robot: {robot.robot_name} ---")
+            raise  # Re-raise exception to be handled by the caller
+    print(f"--- Finished execution for robot: {robot.robot_name} ---")
diff --git a/src/vibe_python/main.py b/src/vibe_python/main.py
new file mode 100644
index 0000000..7560d29
--- /dev/null
+++ b/src/vibe_python/main.py
@@ -0,0 +1,41 @@
+import typer
+from typing_extensions import Annotated
+
+from .config import ConfigManager
+from .executor import execute_robot
+
+app = typer.Typer(help="A Python-based RPA Orchestrator.")
+
+# Initialize the configuration manager once on startup.
+try:
+    config_manager = ConfigManager()
+except Exception as e:
+    typer.echo(f"Failed to initialize configuration: {e}", err=True)
+    raise typer.Exit(code=1)
+
+@app.command()
+def list_robots():
+    """Lists all robots defined in the configuration."""
+    typer.echo("Available Robots:")
+    robots = config_manager.get_all_robots()
+    if not robots:
+        typer.echo("  (No robots found in configuration)")
+        return
+    for robot in robots:
+        status = typer.style("enabled", fg=typer.colors.GREEN) if robot.enabled else typer.style("disabled", fg=typer.colors.RED)
+        typer.echo(f"  - {robot.robot_name} [{status}]")
+
+@app.command()
+def run_now(
+    robot_name: Annotated[str, typer.Argument(help="The name of the robot to run.")]
+):
+    """Immediately runs a single robot."""
+    typer.echo(f"Attempting to run robot: {robot_name}")
+    robot = config_manager.get_robot(robot_name)
+    
+    if not robot:
+        typer.echo(typer.style(f"Error: Robot '{robot_name}' not found.", fg=typer.colors.RED))
+        raise typer.Exit(code=1)
+    if not robot.enabled:
+        typer.echo(typer.style(f"Warning: Robot '{robot_name}' is disabled. Aborting.", fg=typer.colors.YELLOW))
+        raise typer.Exit(code=1)
+
+    try:
+        execute_robot(robot)
+        typer.echo(typer.style(f"Successfully finished running robot '{robot_name}'.", fg=typer.colors.GREEN))
+    except Exception as e:
+        typer.echo(typer.style(f"An error occurred while running robot '{robot_name}': {e}", fg=typer.colors.RED))
+        raise typer.Exit(code=1)
+
+if __name__ == "__main__":
+    app()
diff --git a/src/vibe_python/models.py b/src/vibe_python/models.py
new file mode 100644
index 0000000..cf11e55
--- /dev/null
+++ b/src/vibe_python/models.py
@@ -0,0 +1,56 @@
+import datetime
+from typing import List, Dict, Any, Optional
+
+from pydantic import BaseModel, Field
+from sqlalchemy import (Column, Integer, String, DateTime, Enum as SQLEnum,
+                        ForeignKey)
+from sqlalchemy.orm import declarative_base, relationship
+
+# --- Pydantic Models for Configuration Validation ---
+
+class Schedule(BaseModel):
+    type: str = "cron"
+    expression: str
+
+class OnFailure(BaseModel):
+    retries: int = Field(0, ge=0)
+    delay_seconds: int = Field(60, ge=0)
+
+class Action(BaseModel):
+    type: str
+    params: Dict[str, Any] = Field(default_factory=dict)
+    description: Optional[str] = None
+
+class Robot(BaseModel):
+    robot_name: str
+    description: Optional[str] = None
+    enabled: bool = True
+    schedule: Optional[Schedule] = None
+    on_failure: OnFailure = Field(default_factory=OnFailure)
+    actions: List[Action]
+
+
+# --- SQLAlchemy Models for Database Schema ---
+
+Base = declarative_base()
+
+class TaskRun(Base):
+    __tablename__ = 'task_runs'
+
+    id: int = Column(Integer, primary_key=True, autoincrement=True)
+    robot_name: str = Column(String, nullable=False)
+    status: str = Column(SQLEnum('Pending', 'Running', 'Success', 'Failed', name='task_status_enum'), nullable=False)
+    retry_count: int = Column(Integer, default=0, nullable=False)
+    created_at: datetime.datetime = Column(DateTime, default=datetime.datetime.utcnow)
+    started_at: Optional[datetime.datetime] = Column(DateTime, nullable=True)
+    completed_at: Optional[datetime.datetime] = Column(DateTime, nullable=True)
+    result_message: Optional[str] = Column(String, nullable=True)
+
+    logs = relationship("LogEntry", back_populates="task_run")
+
+class LogEntry(Base):
+    __tablename__ = 'log_entries'
+
+    id: int = Column(Integer, primary_key=True, autoincrement=True)
+    task_run_id: int = Column(Integer, ForeignKey('task_runs.id'), nullable=False)
+    timestamp: datetime.datetime = Column(DateTime, default=datetime.datetime.utcnow)
+    level: str = Column(SQLEnum('INFO', 'WARN', 'ERROR', name='log_level_enum'), nullable=False)
+    message: str = Column(String, nullable=False)
+    screenshot_path: Optional[str] = Column(String, nullable=True)
+
+    task_run = relationship("TaskRun", back_populates="logs")
diff --git a/tests/.gitkeep b/tests/.gitkeep
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/tests/.gitkeep
